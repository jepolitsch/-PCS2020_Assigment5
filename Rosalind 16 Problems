1) PROT

def prot(rna):
    RNA_PRO = {"UUU": "F", "UUC": "F", "UUA": "L", "UUG": "L",
               "UCU": "S", "UCC": "S", "UCA": "S", "UCG": "S",
               "UAU": "Y", "UAC": "Y", "UAA": "STOP", "UAG": "STOP",
               "UGU": "C", "UGC": "C", "UGA": "STOP", "UGG": "W",
               "CUU": "L", "CUC": "L", "CUA": "L", "CUG": "L",
               "CCU": "P", "CCC": "P", "CCA": "P", "CCG": "P",
               "CAU": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
               "CGU": "R", "CGC": "R", "CGA": "R", "CGG": "R",
               "AUU": "I", "AUC": "I", "AUA": "I", "AUG": "M",
               "ACU": "T", "ACC": "T", "ACA": "T", "ACG": "T",
               "AAU": "N", "AAC": "N", "AAA": "K", "AAG": "K",
               "AGU": "S", "AGC": "S", "AGA": "R", "AGG": "R",
               "GUU": "V", "GUC": "V", "GUA": "V", "GUG": "V",
               "GCU": "A", "GCC": "A", "GCA": "A", "GCG": "A",
               "GAU": "D", "GAC": "D", "GAA": "E", "GAG": "E",
               "GGU": "G", "GGC": "G", "GGA": "G", "GGG": "G" }
    rna_lst = (re.findall('...', rna))
    start = int(rna_lst.index('AUG'))
    stop = False
    protein = ''
    if start != -1:
        for p in range((start), len(rna_lst)):
                if p == 'UAG' or p == 'UAA' or p == 'UGA':
                    return protein.replace('STOP', '')
                else:
                    protein += (RNA_PRO.get(rna_lst[p]))

        return protein.replace('STOP', '')
    else:
        return protein.replace('STOP', '')
        
rna = open('rosalind_prot.txt', 'r')
line = rna.readlines()
print(translate(line[0]))

2) SPLC

def splc(coding, exons):
    code = str(coding)
    exons = list(exons)
    for k in exons:
            code = code.replace(k, '')
    rna_coding = RNA(code)
    prot_coding = prot(rna_coding)
    return prot_coding

input_formated = fasta('rosalind_splc.txt', 'results.txt')
dna_just = []
coding = input_formated[0][1]
for x in range(1, len(input_formated)):
    dna_just.insert(x, input_formated[x][1])
print(splc(coding, dna_just))

3) TRAN

def tran(first, second):
    transit = 0
    transv = 0
    for x in range(len(first)):
        a, b = first[x], second[x]
        if a != b:
            if (a == 'G' and b == 'A') or (a == 'A' and b == 'G') or (a == 'C' and b == 'T') or (a == 'T' and b == 'C'):#Transition
                transit += 1
            else:
                transv += 1
    print(transit/transv)

input_formated = fasta('rosalind_tran.txt', 'results.txt')
tran(input_formated[0][1], input_formated[1][1])

4) HAMM

def hamm(one, two):
    counter = 0
    for x in range(len(one)):
        if one[x] != two[x]:
            counter += 1
    return counter
data = open('rosalind_hamm.txt', 'r')
line = data.readlines()
one = line[0]
two = line[1]
print(hamm(one, two))

5) TREE

def tree():
    input = open('rosalind_tree.txt', 'r').readlines()
    n = int(input[0])
    k = len(input[1:])
    print(n-(k+1))
tree()

6) PDST

def p_dist(a,b):
    diff = 0
    for x in range(len(a)):
        if a[x] != b[x]:
            diff += 1
    return "%0.5f" % (diff/len(a))

def pdst(dna):
    for x in range(len(dna)):
        for y in range(len(dna)):
            dist = p_dist(dna[x], dna[y])
            print(dist, end=' ')
        print('')

input_formated = fasta('rosalind_pdst.txt', 'results.txt')
dna_just = []
for x in range(0, len(input_formated)):
    dna_just.insert(x, input_formated[x][1])
pdst(dna_just)

7) SSEQ

def sseq(dna, motif):
    ind = []
    counter = 0
    for k in range(len(motif[0])):
        target = motif[0][k]
        ind.append(dna[0].index(target, counter)+1)
        counter = ind[-1]
    print(*ind)

input_formated = fasta('rosalind_sseq.txt', 'results.txt')
dna_just = [input_formated[0][1]]
motif = [input_formated[1][1]]

sseq(dna_just, motif)

8) LCSQ

def lcsq(s,t):
    lengths = [[0 for j in range(len(t)+1)] for i in range(len(s)+1)]
    for i, x in enumerate(s):
        for j, y in enumerate(t):
            if x == y:
                lengths[i+1][j+1] = lengths[i][j]+1
            else:
                lengths[i+1][j+1] = max(lengths[i+1][j] , lengths[i][j+1])
    motif = ''
    p = len(s)
    k = len(t)
    while p * k != 0:
        if lengths[p][k] == lengths[p-1][k]:
            p -=1
        elif lengths[p][k] == lengths[p][k-1]:
            k -=1
        else:
            motif += s[p- 1]
            p -= 1
            k -= 1
    print(motif)


input_formated = fasta('rosalind_lcsq.txt', 'results.txt')
s = [input_formated[0][1]]
t = [input_formated[1][1]]
lcsq(s[0], t[0])

9) ORF

DNA_CODON_TABLE = {
    'TTT': 'F',     'CTT': 'L',     'ATT': 'I',     'GTT': 'V',
    'TTC': 'F',     'CTC': 'L',     'ATC': 'I',     'GTC': 'V',
    'TTA': 'L',     'CTA': 'L',     'ATA': 'I',     'GTA': 'V',
    'TTG': 'L',     'CTG': 'L',     'ATG': 'M',     'GTG': 'V',
    'TCT': 'S',     'CCT': 'P',     'ACT': 'T',     'GCT': 'A',
    'TCC': 'S',     'CCC': 'P',     'ACC': 'T',     'GCC': 'A',
    'TCA': 'S',     'CCA': 'P',     'ACA': 'T',     'GCA': 'A',
    'TCG': 'S',     'CCG': 'P',     'ACG': 'T',     'GCG': 'A',
    'TAT': 'Y',     'CAT': 'H',     'AAT': 'N',     'GAT': 'D',
    'TAC': 'Y',     'CAC': 'H',     'AAC': 'N',     'GAC': 'D',
    'TAA': 'Stop',  'CAA': 'Q',     'AAA': 'K',     'GAA': 'E',
    'TAG': 'Stop',  'CAG': 'Q',     'AAG': 'K',     'GAG': 'E',
    'TGT': 'C',     'CGT': 'R',     'AGT': 'S',     'GGT': 'G',
    'TGC': 'C',     'CGC': 'R',     'AGC': 'S',     'GGC': 'G',
    'TGA': 'Stop',  'CGA': 'R',     'AGA': 'R',     'GGA': 'G',
    'TGG': 'W',     'CGG': 'R',     'AGG': 'R',     'GGG': 'G'
}


def translate_codon(codon):
    protein = None
    if len(codon) == 3:
        protein = DNA_CODON_TABLE[codon]
    return protein


def orf(dna):
    possible = []
    start_codons = []
    for x in range(len(dna)):
        peptide = translate_codon(dna[x:x + 3])
        if peptide == 'M':
            start_codons.append(x)
    for y in start_codons:
        stop = False
        protein = ''
        for j in range(y, len(dna), 3):
            peptide = translate_codon(dna[j:j + 3])
            if peptide == 'Stop':
                stop = True
                break
            protein += peptide
        if stop == True:
            possible.append(protein)
    return possible

input_formated = fasta('rosalind_orf.txt', 'results.txt')
dna = [input_formated[0][1]]
proteins = set((orf(revc(dna[0]))) + (orf(dna[0])))
print('\n'.join(list(proteins)))


10) PERM

def perm(n):
    num = '12345678'
    k = num[:n]
    p = list(itertools.permutations(k, n))
    print(len(p))
    for x in p:
        print(' '.join(x))
        
11) GRPH

def grph(keys, items):
    for p in range(len(items)):
        ends_with = items[p][-3:]
        for k in items:
            if k.startswith(ends_with) and (keys[p] != ext[items.index(k)]):
                print(keys[p], ext[items.index(k)])

input_formated = fasta('rosalind_grph.txt', 'results.txt')
dna_just = []
ext = []
for x in range(len(input_formated)):
    dna_just.insert(x, input_formated[x][1])
    ext.insert(x, input_formated[x][0])
grph(ext, dna_just)

12) INOD

def inod(n):
    return(n-2)
    
13) EDIT

def edit(s,t):
    if len(s) == 0:
        return len(t)
    if len(t) == 0:
        return len(s)
    if s[len(s) - 1] == t[len(t) - 1]:
        return edit(s[:-1], t[:-1])
    else:
        return 1 + min(edit(s, t[:-1]), edit(s[:-1], t), edit(s[:-1], t[:-1]))

input_formated = fasta('rosalind_edit.txt', 'results.txt')
s = [input_formated[0][1]]
t = [input_formated[1][1]]
print(edit(s[0], t[0]))

14) EDTA

def match(a,b):
    if a == b:
        return(0)
    return(1)


def edta(s,t):
    #Reusing edit distance code for first part
    dist = edit(s, t, len(s), len(t))
    print(dist)
    s_prim = ''
    t_prim = ''
    i = len(s)
    j = len(t)
    #Creating my matrix of i * j
    matrix = [[0 for j in range(len(t)+1)] for i in range(len(s)+1)]
    
    #taking min value of matrix, one of the possible solutions
    for i in range(1,len(s) + 1):
        matrix[i][0] = i
    for i in range(1,len(t)+1):
        matrix[0][i] = i
    for i in range(1,len(s)+1):
        for j in range(1, len(t) + 1):
            if s[i - 1] == t[j - 1]:
                res = 0
            else:
                res = 1
            matrix[i][j] = min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + res)

    #Building the strings given the matrix values
    while i * j != 0:
        if matrix[i][j] == matrix[i-1][j-1] + match(s[i - 1], t[j - 1]):
            s_prim = s[i - 1] + s_prim
            t_prim = t[j - 1] + t_prim
            j -= 1
            i -= 1
        elif i > 0 and matrix[i][j] == matrix[i - 1][j] + 1:
            s_prim = s[i - 1] + s_prim
            t_prim = '-' + t_prim
            i -= 1
        else:
            t_prim = t[j - 1] + t_prim
            s_prim = '-' + s_prim
            j -= 1
    print(s_prim)
    print(t_prim)


input_formated = fasta('rosalind_edta.txt', 'results.txt')
s = [input_formated[0][1]]
t = [input_formated[1][1]]
(edta(s[0], t[0]))

15) GLOB



16) MULT

***17) IPBR

def iprb(k, m, n):
    population = (['AA'] * k) + (['Aa'] * m) + (['aa'] * n)
    all_children = []
    for parent1 in population:
        chosen = population[:]
        chosen.remove(parent1)
        for parent2 in chosen:
            children = itertools.product(parent1, parent2)
            all_children.extend([''.join(c) for c in children])
    dominants = filter(lambda c: 'A' in c, all_children)
    print (float(len(list(dominants))) / len(all_children))
